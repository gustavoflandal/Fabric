// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ============================================
// USUÁRIOS E SEGURANÇA
// ============================================

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password      String
  name          String
  active        Boolean   @default(true)
  lastLogin     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  roles         UserRole[]
  auditLogs     AuditLog[]
  productionPointings ProductionPointing[]
  stockMovements StockMovement[]
  notifications Notification[]
  notificationPreferences NotificationPreference[]
  countingAssignments CountingAssignment[]
  
  // Contagem de Estoque
  countingPlansCreated CountingPlan[] @relation("CountingPlanCreator")
  sessionsAssigned CountingSession[] @relation("SessionAssignedTo")
  sessionsCompleted CountingSession[] @relation("SessionCompletedBy")
  itemsCounted CountingItem[] @relation("ItemCountedBy")
  itemsRecounted CountingItem[] @relation("ItemRecountedBy")
  
  @@map("users")
}

model Role {
  id            String    @id @default(uuid())
  code          String    @unique
  name          String
  description   String?
  active        Boolean   @default(true)
  
  users         UserRole[]
  permissions   RolePermission[]
  notificationRules NotificationRule[]
  
  @@map("roles")
}

model Permission {
  id            String    @id @default(uuid())
  resource      String
  action        String
  description   String?
  
  roles         RolePermission[]
  
  @@unique([resource, action])
  @@map("permissions")
}

model UserRole {
  userId        String
  roleId        String
  assignedAt    DateTime  @default(now())
  
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  role          Role      @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@id([userId, roleId])
  @@map("user_roles")
}

model RolePermission {
  roleId        String
  permissionId  String
  
  role          Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission    Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  @@id([roleId, permissionId])
  @@map("role_permissions")
}

model AuditLog {
  id            String    @id @default(uuid())
  userId        String?
  action        String    @db.VarChar(100)
  resource      String    @db.VarChar(100)
  resourceId    String?
  description   String?   @db.Text
  
  // Dados da requisição HTTP
  ipAddress     String?   @db.VarChar(45)
  userAgent     String?   @db.Text
  method        String?   @db.VarChar(10)
  endpoint      String?   @db.VarChar(500)
  statusCode    Int?
  
  // Dados de auditoria
  requestBody   Json?
  responseBody  Json?
  oldValues     Json?
  newValues     Json?
  errorMessage  String?   @db.Text
  durationMs    Int?
  
  createdAt     DateTime  @default(now())
  
  user          User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([resource])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================
// CADASTROS BÁSICOS
// ============================================

model WorkCenter {
  id            String    @id @default(uuid())
  code          String    @unique
  name          String
  description   String?
  type          String
  capacity      Float?
  efficiency    Float     @default(1.0)
  costPerHour   Float?
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  operations    RoutingOperation[]
  productionOperations ProductionOrderOperation[]
  
  @@map("work_centers")
}

model UnitOfMeasure {
  id            String    @id @default(uuid())
  code          String    @unique
  name          String
  type          String    // length, weight, volume, quantity, time
  symbol        String?
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  products      Product[]
  bomItems      BOMItem[]
  
  @@map("units_of_measure")
}

model Supplier {
  id            String    @id @default(uuid())
  code          String    @unique
  name          String
  legalName     String?
  document      String?
  email         String?
  phone         String?
  address       String?
  city          String?
  state         String?
  zipCode       String?
  country       String    @default("BR")
  paymentTerms  String?
  leadTime      Int?
  rating        Float?
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  quotations    PurchaseQuotation[]
  purchaseOrders PurchaseOrder[]
  
  @@map("suppliers")
}

model Customer {
  id            String    @id @default(uuid())
  code          String    @unique
  name          String
  legalName     String?
  document      String?
  email         String?
  phone         String?
  address       String?
  city          String?
  state         String?
  zipCode       String?
  country       String    @default("BR")
  paymentTerms  String?
  creditLimit   Float?
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@map("customers")
}

// ============================================
// ENGENHARIA DE PRODUTOS
// ============================================

model Product {
  id            String    @id @default(uuid())
  code          String    @unique
  name          String
  description   String?   @db.Text
  type          String
  unitId        String
  categoryId    String?
  
  leadTime      Int       @default(0)
  lotSize       Float?
  
  minStock      Float     @default(0)
  maxStock      Float?
  safetyStock   Float     @default(0)
  reorderPoint  Float?
  
  standardCost  Float?
  lastCost      Float?
  averageCost   Float?
  
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  unit          UnitOfMeasure @relation(fields: [unitId], references: [id])
  category      ProductCategory? @relation(fields: [categoryId], references: [id])
  
  boms          BOM[]
  bomItems      BOMItem[]
  routings      Routing[]
  productionOrders ProductionOrder[]
  stockMovements StockMovement[]
  quotationItems PurchaseQuotationItem[]
  purchaseOrderItems PurchaseOrderItem[]
  receiptItems  PurchaseReceiptItem[]
  countingItems CountingItem[]
  countingPlanProducts CountingPlanProduct[]
  
  @@index([type])
  @@index([active])
  @@map("products")
}

model ProductCategory {
  id            String    @id @default(uuid())
  code          String    @unique
  name          String
  description   String?
  parentId      String?
  
  parent        ProductCategory? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children      ProductCategory[] @relation("CategoryHierarchy")
  products      Product[]
  
  @@map("product_categories")
}

model BOM {
  id            String    @id @default(uuid())
  productId     String
  version       Int       @default(1)
  description   String?
  validFrom     DateTime  @default(now())
  validTo       DateTime?
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  product       Product   @relation(fields: [productId], references: [id])
  items         BOMItem[]
  
  @@unique([productId, version])
  @@index([productId, active])
  @@map("boms")
}

model BOMItem {
  id            String    @id @default(uuid())
  bomId         String
  componentId   String
  quantity      Float
  unitId        String
  scrapFactor   Float     @default(0)
  sequence      Int
  notes         String?
  
  bom           BOM       @relation(fields: [bomId], references: [id], onDelete: Cascade)
  component     Product   @relation(fields: [componentId], references: [id])
  unit          UnitOfMeasure @relation(fields: [unitId], references: [id])
  
  @@index([bomId])
  @@map("bom_items")
}

model Routing {
  id            String    @id @default(uuid())
  productId     String
  version       Int       @default(1)
  description   String?
  validFrom     DateTime  @default(now())
  validTo       DateTime?
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  product       Product   @relation(fields: [productId], references: [id])
  operations    RoutingOperation[]
  
  @@unique([productId, version])
  @@index([productId, active])
  @@map("routings")
}

model RoutingOperation {
  id            String    @id @default(uuid())
  routingId     String
  sequence      Int
  workCenterId  String
  description   String
  setupTime     Float
  runTime       Float
  queueTime     Float     @default(0)
  moveTime      Float     @default(0)
  notes         String?
  
  routing       Routing   @relation(fields: [routingId], references: [id], onDelete: Cascade)
  workCenter    WorkCenter @relation(fields: [workCenterId], references: [id])
  
  @@index([routingId])
  @@map("routing_operations")
}

// ============================================
// PRODUÇÃO
// ============================================

model ProductionOrder {
  id            String    @id @default(uuid())
  orderNumber   String    @unique
  productId     String
  quantity      Float
  producedQty   Float     @default(0)
  scrapQty      Float     @default(0)
  priority      Int       @default(5)
  status        String    @default("PLANNED")
  
  scheduledStart DateTime
  scheduledEnd  DateTime
  actualStart   DateTime?
  actualEnd     DateTime?
  
  plannedCost   Float?
  actualCost    Float?
  
  notes         String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  createdBy     String
  
  product       Product   @relation(fields: [productId], references: [id])
  operations    ProductionOrderOperation[]
  pointings     ProductionPointing[]
  
  @@index([status])
  @@index([scheduledStart])
  @@index([productId])
  @@map("production_orders")
}

model ProductionOrderOperation {
  id            String    @id @default(uuid())
  productionOrderId String
  sequence      Int
  workCenterId  String
  description   String
  
  plannedQty    Float
  completedQty  Float     @default(0)
  scrapQty      Float     @default(0)
  
  setupTime     Float
  runTime       Float
  totalPlannedTime Float
  actualTime    Float     @default(0)
  
  status        String    @default("PENDING")
  scheduledStart DateTime?
  scheduledEnd  DateTime?
  actualStart   DateTime?
  actualEnd     DateTime?
  
  productionOrder ProductionOrder @relation(fields: [productionOrderId], references: [id], onDelete: Cascade)
  workCenter    WorkCenter @relation(fields: [workCenterId], references: [id])
  pointings     ProductionPointing[]
  
  @@index([productionOrderId])
  @@index([workCenterId])
  @@index([status])
  @@map("production_order_operations")
}

model ProductionPointing {
  id            String    @id @default(uuid())
  productionOrderId String
  operationId   String
  userId        String
  
  quantityGood  Float
  quantityScrap Float     @default(0)
  
  setupTime     Float     @default(0)
  runTime       Float
  
  startTime     DateTime
  endTime       DateTime
  
  notes         String?
  createdAt     DateTime  @default(now())
  
  productionOrder ProductionOrder @relation(fields: [productionOrderId], references: [id])
  operation     ProductionOrderOperation @relation(fields: [operationId], references: [id])
  user          User      @relation(fields: [userId], references: [id])
  
  @@index([productionOrderId])
  @@index([operationId])
  @@index([userId])
  @@index([startTime])
  @@map("production_pointings")
}

// ============================================
// ESTOQUE
// ============================================

model StockMovement {
  id            String    @id @default(uuid())
  productId     String
  type          String    // IN, OUT, ADJUSTMENT
  quantity      Float
  reason        String
  reference     String?   // ID da OP, Pedido, etc
  referenceType String?   // PRODUCTION, PURCHASE, ADJUSTMENT
  userId        String
  notes         String?
  createdAt     DateTime  @default(now())
  
  product       Product   @relation(fields: [productId], references: [id])
  user          User      @relation(fields: [userId], references: [id])
  countingSession CountingSession? @relation("CountingAdjustments", fields: [reference], references: [id])
  
  @@index([productId])
  @@index([type])
  @@index([createdAt])
  @@index([reference])
  @@map("stock_movements")
}

// ============================================
// COMPRAS
// ============================================

model PurchaseQuotation {
  id            String    @id @default(uuid())
  quotationNumber String  @unique
  supplierId    String
  requestDate   DateTime  @default(now())
  dueDate       DateTime
  status        String    @default("PENDING") // PENDING, SENT, RECEIVED, APPROVED, REJECTED, EXPIRED
  notes         String?   @db.Text
  totalValue    Float     @default(0)
  createdBy     String
  approvedBy    String?
  approvedAt    DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  supplier      Supplier  @relation(fields: [supplierId], references: [id])
  items         PurchaseQuotationItem[]
  purchaseOrders PurchaseOrder[]
  
  @@index([supplierId])
  @@index([status])
  @@index([requestDate])
  @@map("purchase_quotations")
}

model PurchaseQuotationItem {
  id            String    @id @default(uuid())
  quotationId   String
  productId     String
  quantity      Float
  unitPrice     Float
  discount      Float     @default(0)
  totalPrice    Float
  deliveryDays  Int?
  notes         String?
  
  quotation     PurchaseQuotation @relation(fields: [quotationId], references: [id], onDelete: Cascade)
  product       Product   @relation(fields: [productId], references: [id])
  
  @@index([quotationId])
  @@index([productId])
  @@map("purchase_quotation_items")
}

model PurchaseOrder {
  id            String    @id @default(uuid())
  orderNumber   String    @unique
  supplierId    String
  quotationId   String?
  orderDate     DateTime  @default(now())
  expectedDate  DateTime
  receivedDate  DateTime?
  status        String    @default("PENDING") // PENDING, CONFIRMED, PARTIAL, RECEIVED, CANCELLED
  paymentTerms  String?
  paymentMethod String?
  shippingCost  Float     @default(0)
  discount      Float     @default(0)
  totalValue    Float
  notes         String?   @db.Text
  createdBy     String
  approvedBy    String?
  approvedAt    DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  supplier      Supplier  @relation(fields: [supplierId], references: [id])
  quotation     PurchaseQuotation? @relation(fields: [quotationId], references: [id])
  items         PurchaseOrderItem[]
  receipts      PurchaseReceipt[]
  
  @@index([supplierId])
  @@index([quotationId])
  @@index([status])
  @@index([orderDate])
  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id            String    @id @default(uuid())
  orderId       String
  productId     String
  quantity      Float
  receivedQty   Float     @default(0)
  unitPrice     Float
  discount      Float     @default(0)
  totalPrice    Float
  notes         String?
  
  order         PurchaseOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product       Product   @relation(fields: [productId], references: [id])
  receiptItems  PurchaseReceiptItem[]
  
  @@index([orderId])
  @@index([productId])
  @@map("purchase_order_items")
}

model PurchaseReceipt {
  id            String    @id @default(uuid())
  receiptNumber String    @unique
  orderId       String
  receiptDate   DateTime  @default(now())
  receivedBy    String
  notes         String?   @db.Text
  status        String    @default("PENDING") // PENDING, APPROVED, REJECTED
  createdAt     DateTime  @default(now())
  
  order         PurchaseOrder @relation(fields: [orderId], references: [id])
  items         PurchaseReceiptItem[]
  
  @@index([orderId])
  @@index([receiptDate])
  @@map("purchase_receipts")
}

model PurchaseReceiptItem {
  id            String    @id @default(uuid())
  receiptId     String
  orderItemId   String
  productId     String
  quantity      Float
  acceptedQty   Float
  rejectedQty   Float     @default(0)
  notes         String?
  
  receipt       PurchaseReceipt @relation(fields: [receiptId], references: [id], onDelete: Cascade)
  orderItem     PurchaseOrderItem @relation(fields: [orderItemId], references: [id])
  product       Product   @relation(fields: [productId], references: [id])
  
  @@index([receiptId])
  @@index([orderItemId])
  @@index([productId])
  @@map("purchase_receipt_items")
}

// ============================================
// NOTIFICAÇÕES
// ============================================

model Notification {
  id            String    @id @default(uuid())
  userId        String
  type          String    // INFO, WARNING, ERROR, SUCCESS
  category      String    // PRODUCTION, STOCK, PURCHASE, QUALITY, CAPACITY
  eventType     String    // PRODUCTION_DELAYED, STOCK_BELOW_SAFETY, etc
  title         String
  message       String    @db.Text
  data          Json?     // Dados contextuais adicionais
  
  // Navegação
  link          String?   // URL para ir direto ao recurso
  resourceType  String?   // ProductionOrder, Product, PurchaseOrder, etc
  resourceId    String?
  
  // Estado
  read          Boolean   @default(false)
  readAt        DateTime?
  archived      Boolean   @default(false)
  archivedAt    DateTime?
  
  // Prioridade
  priority      Int       @default(1) // 1=baixa, 2=média, 3=alta, 4=crítica
  expiresAt     DateTime?
  
  createdAt     DateTime  @default(now())
  
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, read])
  @@index([userId, archived])
  @@index([category])
  @@index([eventType])
  @@index([priority])
  @@index([createdAt])
  @@index([resourceType, resourceId])
  @@map("notifications")
}

model NotificationRule {
  id            String    @id @default(uuid())
  roleId        String
  eventType     String    // Tipo de evento que dispara a notificação
  
  // Configurações
  enabled       Boolean   @default(true)
  minPriority   Int       @default(1)
  
  // Canais de entrega
  inApp         Boolean   @default(true)
  email         Boolean   @default(false)
  
  // Condições adicionais (JSON)
  conditions    Json?     // Ex: { "workCenterId": "xxx", "assignedOnly": true }
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  role          Role      @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@unique([roleId, eventType])
  @@map("notification_rules")
}

model NotificationPreference {
  id            String    @id @default(uuid())
  userId        String
  category      String    // PRODUCTION, STOCK, PURCHASE, QUALITY, CAPACITY
  
  // Canais habilitados por categoria
  inApp         Boolean   @default(true)
  email         Boolean   @default(false)
  
  // Filtros
  minPriority   Int       @default(1)
  enabled       Boolean   @default(true)
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, category])
  @@map("notification_preferences")
}

// ============================================
// MÓDULO DE CONTAGEM DE ESTOQUE
// ============================================

// Localização Física
model Location {
  id            String    @id @default(uuid())
  code          String    @unique
  name          String
  type          LocationType
  parentId      String?
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  parent        Location?  @relation("LocationHierarchy", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children      Location[] @relation("LocationHierarchy")
  countingItems CountingItem[]
  
  @@index([parentId])
  @@index([type, active])
  @@map("locations")
}

// Plano de Contagem
model CountingPlan {
  id                String              @id @default(uuid())
  code              String              @unique
  name              String
  description       String?             @db.Text
  type              CountingType
  frequency         CountingFrequency?
  status            CountingPlanStatus  @default(DRAFT)
  
  // Critérios de seleção (JSON)
  criteria          Json?
  
  // Configurações
  allowBlindCount   Boolean             @default(true)
  requireRecount    Boolean             @default(true)
  tolerancePercent  Decimal?            @db.Decimal(5, 2)
  toleranceQty      Int?
  priority          Int                 @default(5)
  
  // Datas
  startDate         DateTime
  endDate           DateTime?
  nextExecution     DateTime?
  
  // Responsável
  createdBy         String
  
  // Auditoria
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  // Relações
  creator           User                @relation("CountingPlanCreator", fields: [createdBy], references: [id])
  sessions          CountingSession[]
  products          CountingPlanProduct[]
  
  @@index([status, nextExecution])
  @@index([type, frequency])
  @@index([createdBy])
  @@map("counting_plans")
}

// Sessão de Contagem (Execução do plano)
model CountingSession {
  id                String              @id @default(uuid())
  code              String              @unique
  planId            String
  status            SessionStatus       @default(SCHEDULED)
  
  // Datas
  scheduledDate     DateTime
  startedAt         DateTime?
  completedAt       DateTime?
  
  // Responsáveis
  assignedTo        String?
  completedBy       String?
  
  // Estatísticas
  totalItems        Int                 @default(0)
  countedItems      Int                 @default(0)
  itemsWithDiff     Int                 @default(0)
  accuracyPercent   Decimal?            @db.Decimal(5, 2)
  
  // Auditoria
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  // Relações
  plan              CountingPlan        @relation(fields: [planId], references: [id])
  assignedUser      User?               @relation("SessionAssignedTo", fields: [assignedTo], references: [id])
  completedUser     User?               @relation("SessionCompletedBy", fields: [completedBy], references: [id])
  items             CountingItem[]
  adjustments       StockMovement[]     @relation("CountingAdjustments")
  assignments       CountingAssignment[]
  
  @@index([planId])
  @@index([status, scheduledDate])
  @@index([assignedTo])
  @@map("counting_sessions")
}

// Item de Contagem
model CountingItem {
  id                String              @id @default(uuid())
  sessionId         String
  productId         String
  locationId        String?
  
  // Quantidades
  systemQty         Decimal             @db.Decimal(10, 2)
  countedQty        Decimal?            @db.Decimal(10, 2)
  recountQty        Decimal?            @db.Decimal(10, 2)
  finalQty          Decimal?            @db.Decimal(10, 2)
  
  // Divergência
  difference        Decimal?            @db.Decimal(10, 2)
  differencePercent Decimal?            @db.Decimal(5, 2)
  hasDifference     Boolean             @default(false)
  
  // Status
  status            CountingItemStatus  @default(PENDING)
  
  // Observações
  notes             String?             @db.Text
  reason            String?             @db.Text
  
  // Contadores
  countedBy         String?
  countedAt         DateTime?
  recountedBy       String?
  recountedAt       DateTime?
  
  // Sequência para ordenação
  sequence          Int?               @default(0)
  
  // Auditoria
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  // Relações
  session           CountingSession     @relation(fields: [sessionId], references: [id])
  product           Product             @relation(fields: [productId], references: [id])
  location          Location?           @relation(fields: [locationId], references: [id])
  counter           User?               @relation("ItemCountedBy", fields: [countedBy], references: [id])
  recounter         User?               @relation("ItemRecountedBy", fields: [recountedBy], references: [id])
  
  @@index([sessionId, status])
  @@index([productId])
  @@index([hasDifference])
  @@index([countedBy])
  @@map("counting_items")
}

// Relação de produtos em planos de contagem
model CountingPlanProduct {
  id                String        @id @default(uuid())
  planId            String
  productId         String
  priority          Int           @default(0)
  
  plan              CountingPlan  @relation(fields: [planId], references: [id])
  product           Product       @relation(fields: [productId], references: [id])
  
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  
  @@unique([planId, productId])
  @@map("counting_plan_products")
}

// Atribuição de contadores a sessões
model CountingAssignment {
  id                String            @id @default(uuid())
  sessionId         String
  userId            String
  role              CounterRole
  assignedAt        DateTime          @default(now())
  
  session           CountingSession   @relation(fields: [sessionId], references: [id])
  user              User              @relation(fields: [userId], references: [id])
  
  @@unique([sessionId, userId])
  @@map("counting_assignments")
}

// Papéis de contador
enum CounterRole {
  PRIMARY     // Contador principal
  SECONDARY   // Recontador
  VALIDATOR   // Validador final
  SUPERVISOR  // Supervisor
}

// ============================================
// ENUMS - CONTAGEM DE ESTOQUE
// ============================================

enum LocationType {
  WAREHOUSE
  AREA
  CORRIDOR
  SHELF
  BIN
  FLOOR
}

enum CountingType {
  CYCLIC
  SPOT
  FULL_INVENTORY
  BLIND
}

enum CountingFrequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  QUARTERLY
  SEMIANNUAL
  ANNUAL
  ON_DEMAND
}

enum CountingPlanStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum SessionStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum CountingItemStatus {
  PENDING
  COUNTED
  RECOUNTED
  ADJUSTED
  CANCELLED
}

model Warehouse {
  id            String    @id @default(uuid())
  code          String    @unique
  name          String
  legalName     String?
  document      String?
  email         String?
  phone         String?
  address       String?
  city          String?
  state         String?
  zipCode       String?
  country       String    @default("BR")
  managerName   String?
  capacity      Float?
  description   String?   @db.Text
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  structures      WarehouseStructure[]

  @@map("warehouses")
}

model WarehouseStructure {
  id              String   @id @default(uuid())
  warehouseId     String
  streetCode      String
  floors          Int
  positions       Int
  weightCapacity  Float
  height          Float
  width           Float
  depth           Float
  maxHeight       Float
  blocked         Boolean  @default(false)
  positionType    PositionType
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  warehouse       Warehouse @relation(fields: [warehouseId], references: [id])
  storagePositions StoragePosition[]

  @@map("warehouse_structures")
}

model StoragePosition {
  id              String   @id @default(uuid())
  structureId     String
  warehouseCode   String
  streetCode      String
  floor           Int
  position        Int
  positionType    PositionType
  weightCapacity  Float
  height          Float
  width           Float
  depth           Float
  maxHeight       Float
  blocked         Boolean  @default(false)
  occupied        Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  structure       WarehouseStructure @relation(fields: [structureId], references: [id], onDelete: Cascade)

  @@unique([structureId, floor, position])
  @@index([warehouseCode, streetCode])
  @@index([blocked])
  @@index([occupied])
  @@map("storage_positions")
}

enum PositionType {
  PORTA_PALETES
  MINI_PORTA_PALETES
  DRIVE_IN
  DRIVE_THROUGH
  PUSH_BACK
  FLOW_RACK
  CANTILEVER
  MEZANINO
  AUTOPORTANTE
  RACKS
  CARROSSEL
  MINI_LOAD
  ESTANTES_INDUSTRIAIS
}
